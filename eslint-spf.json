[{"filePath":"C:\\Projects\\better-cloudflare\\test\\spf.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":41,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":41,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":42,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":42,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":43,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":44,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":45,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":45,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":46,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1715,1718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1715,1718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2443,2446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2443,2446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":68,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2543,2546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2543,2546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":77,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2968,2971],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2968,2971],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3057,3060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3057,3060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3376,3379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3376,3379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":94,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":95,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":95,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":96,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":97,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":97,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":98,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4045,4048],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4045,4048],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":103,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4262,4265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4262,4265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":114,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":114,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":115,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":115,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":116,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":116,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":117,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":118,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4978,4981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4978,4981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":133,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":133,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":134,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":134,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":136,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":136,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":137,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":137,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5839,5842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5839,5842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":151,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":151,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":152,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":152,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":153,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":153,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":154,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":154,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":155,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":156,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":156,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6509,6512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6509,6512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":183,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":183,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":184,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":184,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_d' is defined but never used.","line":185,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":185,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_ip' is defined but never used.","line":186,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":186,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":187,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":187,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7671,7674],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7671,7674],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":39,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import assert from 'node:assert/strict';\r\nimport { test } from 'node:test';\r\nimport { parseSPF, composeSPF, validateSPF, SPFRecord, setDnsResolverForTest, ipMatchesCIDR } from '../src/lib/spf';\r\nimport { buildSPFGraphFromContent, validateSPFContentAsync, simulateSPF, expandSPFMacro } from '../src/lib/spf';\r\n\r\ntest('parseSPF should parse mechanisms', () => {\r\n  const input = 'v=spf1 ip4:1.2.3.0/24 include:example.com -all';\r\n  const parsed = parseSPF(input);\r\n  assert.ok(parsed);\r\n  assert.equal(parsed?.version, 'v=spf1');\r\n  assert.equal(parsed?.mechanisms.length, 3);\r\n  assert.equal(parsed?.mechanisms[0].mechanism, 'ip4');\r\n  assert.equal(parsed?.mechanisms[1].mechanism, 'include');\r\n});\r\n\r\ntest('composeSPF should create spf string from record', () => {\r\n  const rec: SPFRecord = {\r\n    version: 'v=spf1',\r\n    mechanisms: [\r\n      { mechanism: 'ip4', value: '1.2.3.0/24' },\r\n      { mechanism: 'all' }\r\n    ]\r\n  };\r\n  const s = composeSPF(rec);\r\n  assert.ok(s.startsWith('v=spf1'));\r\n});\r\n\r\ntest('validateSPF should flag errors when missing prefix', () => {\r\n  const res = validateSPF('ip4:1.2.3.4');\r\n  assert.equal(res.ok, false);\r\n});\r\n\r\ntest('validateSPF should accept valid spf', () => {\r\n  const res = validateSPF('v=spf1 ip4:1.2.3.0/24 -all');\r\n  assert.equal(res.ok, true);\r\n});\r\n\r\ntest('simulateSPF should detect ip4 pass', async () => {\r\n  const domain = 'example.local';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (_d: string) => ([['v=spf1 ip4:1.2.3.0/24 -all']]),\r\n    resolve4: async (_d: string) => ['1.2.3.5'],\r\n    resolve6: async (_d: string) => [],\r\n    resolveMx: async (_d: string) => [],\r\n    reverse: async (_ip: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const res = await simulateSPF({ domain, ip: '1.2.3.5' });\r\n    assert.equal(res.result, 'pass');\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('ipMatchesCIDR should support IPv6 CIDR matching', () => {\r\n  assert.ok(ipMatchesCIDR('2001:db8::1', '2001:db8::/32'));\r\n  assert.ok(!ipMatchesCIDR('2001:db9::1', '2001:db8::/32'));\r\n});\r\n\r\ntest('composeSPF and parseSPF support add/edit/remove operations', () => {\r\n  const base = 'v=spf1 ip4:1.2.3.0/24 -all';\r\n  const parsed = parseSPF(base);\r\n  assert.ok(parsed);\r\n  // add an include\r\n  const mechs = [...(parsed?.mechanisms ?? [])];\r\n  mechs.push({ mechanism: 'include', value: 'inc.example' as any });\r\n  const composed = composeSPF({ version: parsed?.version ?? 'v=spf1', mechanisms: mechs as any });\r\n  \r\n  const parsed2 = parseSPF(composed);\r\n  \r\n  assert.equal(parsed2?.mechanisms.some((m) => m.mechanism === 'include' && m.value === 'inc.example'), true);\r\n  // edit the include to ip6 value\r\n  const idx = parsed2?.mechanisms.findIndex((m) => m.mechanism === 'include') ?? -1;\r\n  if (idx >= 0 && parsed2) {\r\n    const mechs2 = [...parsed2.mechanisms];\r\n    mechs2[idx] = { mechanism: 'ip6', value: '::1/128' } as any;\r\n    const composed2 = composeSPF({ version: parsed2.version, mechanisms: mechs2 as any });\r\n    const parsed3 = parseSPF(composed2);\r\n    assert.equal(parsed3?.mechanisms.some((m) => m.mechanism === 'ip6' && m.value === '::1/128'), true);\r\n    // remove the ip6\r\n    const mechs3 = mechs2.filter((_, i) => i !== idx);\r\n    const composed3 = composeSPF({ version: parsed3.version, mechanisms: mechs3 as any });\r\n    const parsed4 = parseSPF(composed3);\r\n    assert.equal(parsed4?.mechanisms.some((m) => m.mechanism === 'ip6' && m.value === '::1/128'), false);\r\n  }\r\n});\r\n\r\ntest('buildSPFGraphFromContent should build include nodes', async () => {\r\n  const domain = 'example.org';\r\n  const content = 'v=spf1 include:inc.example -all';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (d: string) => (d === 'inc.example' ? [['v=spf1 ip4:1.2.3.0/24 -all']] : []),\r\n    resolve4: async (_d: string) => [],\r\n    resolve6: async (_d: string) => [],\r\n    resolveMx: async (_d: string) => [],\r\n    reverse: async (_ip: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const graph = await buildSPFGraphFromContent(domain, content);\r\n    assert.equal(graph.nodes.length >= 1, true);\r\n    const includes = graph.edges.filter((e: any) => e.type === 'include');\r\n    assert.equal(includes.length, 1);\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('validateSPFContentAsync should reject lookup limit', async () => {\r\n  const domain = 'example.org';\r\n  const content = 'v=spf1 include:one include:two include:three include:four include:five include:six include:seven include:eight include:nine include:ten include:eleven -all';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (_d: string) => [['v=spf1 -all']],\r\n    resolve4: async (_d: string) => [],\r\n    resolve6: async (_d: string) => [],\r\n    resolveMx: async (_d: string) => [],\r\n    reverse: async (_ip: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const res = await validateSPFContentAsync(content, domain, { maxLookups: 10 });\r\n    assert.equal(res.ok, false);\r\n    assert.ok(res.problems.some((p: string) => p.indexOf('requires') !== -1 || p.indexOf('exceeds') !== -1 || p.indexOf('DNS lookups') !== -1));\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('simulateSPF should honor ptr with forward-confirmation', async () => {\r\n  const domain = 'ptr.example';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (_d: string) => ([['v=spf1 ptr:example.com -all']]),\r\n    reverse: async (_ip: string) => ['example.com'],\r\n    resolve4: async (d: string) => (d === 'example.com' ? ['1.2.3.4'] : []),\r\n    resolve6: async (_d: string) => ([]),\r\n    resolveMx: async (_d: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const res = await simulateSPF({ domain, ip: '1.2.3.4' });\r\n    assert.equal(res.result, 'pass');\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('simulateSPF should not match ptr without forward-confirmation', async () => {\r\n  const domain = 'ptr.example';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (_d: string) => ([['v=spf1 ptr:example.com -all']]),\r\n    reverse: async (_ip: string) => ['example.com'],\r\n    resolve4: async (_d: string) => ([]),\r\n    resolve6: async (_d: string) => ([]),\r\n    resolveMx: async (_d: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const res = await simulateSPF({ domain, ip: '1.2.3.4' });\r\n    assert.equal(res.result, 'fail');\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('expandSPFMacro basic tokens', () => {\r\n  const out = expandSPFMacro('%{s} hello %{l} %{d} %{i} %% %_', { domain: 'example.com', ip: '1.2.3.4', sender: 'user@example.com' });\r\n  assert.ok(out.includes('user@example.com'));\r\n  assert.ok(out.includes('user'));\r\n  assert.ok(out.includes('example.com'));\r\n  assert.ok(out.includes('1.2.3.4'));\r\n  assert.ok(out.includes('%'));\r\n});\r\n\r\ntest('simulateSPF should include exp TXT explanation on fail', async () => {\r\n  const domain = 'exp.example';\r\n  const mockResolver: import('../src/lib/spf').DNSResolver = {\r\n    resolveTxt: async (d: string) => {\r\n      if (d === 'explain.exp.example') return [['Explanation text']];\r\n      if (d === domain) return [['v=spf1 -all exp=explain.%{d}']];\r\n      return [];\r\n    },\r\n    resolve4: async (_d: string) => [],\r\n    resolve6: async (_d: string) => [],\r\n    resolveMx: async (_d: string) => [],\r\n    reverse: async (_ip: string) => [],\r\n  } as any;\r\n  setDnsResolverForTest(mockResolver);\r\n  try {\r\n    const res = await simulateSPF({ domain, ip: '1.2.3.4' });\r\n    assert.equal(res.result, 'fail');\r\n    assert.ok(res.reasons.some((r) => String(r).includes('explain=Explanation')));\r\n  } finally {\r\n    setDnsResolverForTest(undefined);\r\n  }\r\n});\r\n\r\ntest('ipMatchesCIDR should treat IPv4-mapped IPv6 as IPv4 for IPv4 CIDRs', () => {\r\n  assert.ok(ipMatchesCIDR('::ffff:1.2.3.5', '1.2.3.0/24'));\r\n  assert.ok(!ipMatchesCIDR('::ffff:2.2.3.5', '1.2.3.0/24'));\r\n});\r\n","usedDeprecatedRules":[]}]
